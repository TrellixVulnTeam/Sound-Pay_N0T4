{"version":3,"file":"transloco.service.d.ts","sources":["transloco.service.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { OnDestroy } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\nimport { TranslocoLoader } from './transloco.loader';\r\nimport { TranslocoTranspiler } from './transloco.transpiler';\r\nimport { AvailableLangs, HashMap, InlineLoader, LoadOptions, SetTranslationOptions, TranslateParams, Translation, TranslocoEvents, TranslocoScope } from './types';\r\nimport { TranslocoConfig } from './transloco.config';\r\nimport { TranslocoMissingHandler } from './transloco-missing-handler';\r\nimport { TranslocoInterceptor } from './transloco.interceptor';\r\nimport { TranslocoFallbackStrategy } from './transloco-fallback-strategy';\r\nexport declare function translate<T = any>(key: TranslateParams, params?: HashMap, lang?: string): T;\r\nexport declare class TranslocoService implements OnDestroy {\r\n    private loader;\r\n    private parser;\r\n    private missingHandler;\r\n    private interceptor;\r\n    private userConfig;\r\n    private fallbackStrategy;\r\n    private subscription;\r\n    private translations;\r\n    private cache;\r\n    private firstFallbackLang;\r\n    private defaultLang;\r\n    private mergedConfig;\r\n    private availableLangs;\r\n    private isResolvedMissingOnce;\r\n    private lang;\r\n    langChanges$: Observable<string>;\r\n    private events;\r\n    events$: Observable<TranslocoEvents>;\r\n    private failedLangs;\r\n    constructor(loader: TranslocoLoader, parser: TranslocoTranspiler, missingHandler: TranslocoMissingHandler, interceptor: TranslocoInterceptor, userConfig: TranslocoConfig, fallbackStrategy: TranslocoFallbackStrategy);\r\n    readonly config: TranslocoConfig;\r\n    getDefaultLang(): string;\r\n    setDefaultLang(lang: string): void;\r\n    getActiveLang(): string;\r\n    setActiveLang(lang: string): this;\r\n    setAvailableLangs(langs: AvailableLangs): void;\r\n    /**\r\n     * Gets the available languages.\r\n     *\r\n     * @returns\r\n     * An array of the available languages. Can be either a `string[]` or a `{ id: string; label: string }[]`\r\n     * depending on how the available languages are set in your module.\r\n     */\r\n    getAvailableLangs(): AvailableLangs;\r\n    load(path: string, options?: LoadOptions): Observable<Translation>;\r\n    /**\r\n     * Gets the instant translated value of a key\r\n     *\r\n     * @example\r\n     *\r\n     * translate<string>('hello')\r\n     * translate('hello', { value: 'value' })\r\n     * translate<string[]>(['hello', 'key'])\r\n     * translate('hello', { }, 'en')\r\n     * translate('scope.someKey', { }, 'en')\r\n     */\r\n    translate<T = any>(key: TranslateParams, params?: HashMap, lang?: string): T;\r\n    /**\r\n     * Gets the translated value of a key as observable\r\n     *\r\n     * @example\r\n     *\r\n     * selectTranslate<string>('hello').subscribe(value => ...)\r\n     * selectTranslate<string>('hello', {}, 'es').subscribe(value => ...)\r\n     * selectTranslate<string>('hello', {}, 'todos').subscribe(value => ...)\r\n     * selectTranslate<string>('hello', {}, { scope: 'todos' }).subscribe(value => ...)\r\n     *\r\n     */\r\n    selectTranslate<T = any>(key: TranslateParams, params?: HashMap, lang?: string | TranslocoScope, _isObject?: boolean): Observable<T>;\r\n    /**\r\n     * Whether the scope with lang\r\n     *\r\n     * @example\r\n     *\r\n     * todos/en => true\r\n     * todos => false\r\n     */\r\n    private isScopeWithLang;\r\n    /**\r\n     * Translate the given path that returns an object\r\n     *\r\n     * @example\r\n     *\r\n     * service.translateObject('path.to.object', {'subpath': { value: 'someValue'}}) => returns translated object\r\n     *\r\n     */\r\n    translateObject<T = any>(key: string, params?: HashMap, lang?: string): T;\r\n    translateObject<T = any>(key: string[], params?: HashMap, lang?: string): T[];\r\n    translateObject<T = any>(key: TranslateParams, params?: HashMap, lang?: string): T | T[];\r\n    translateObject<T = any>(key: HashMap | Map<string, HashMap>, params?: null, lang?: string): T[];\r\n    selectTranslateObject<T = any>(key: string, params?: HashMap, lang?: string): Observable<T>;\r\n    selectTranslateObject<T = any>(key: string[], params?: HashMap, lang?: string): Observable<T[]>;\r\n    selectTranslateObject<T = any>(key: HashMap | Map<string, HashMap>, params?: null, lang?: string): Observable<T[]>;\r\n    /**\r\n     * Gets an object of translations for a given language\r\n     *\r\n     * @example\r\n     *\r\n     * getTranslation()\r\n     * getTranslation('en')\r\n     * getTranslation('admin-page/en')\r\n     */\r\n    getTranslation(): Map<string, Translation>;\r\n    getTranslation(langOrScope: string): Translation;\r\n    /**\r\n     * Gets an object of translations for a given language\r\n     *\r\n     * @example\r\n     *\r\n     * selectTranslation().subscribe() - will return the current lang translation\r\n     * selectTranslation('es').subscribe()\r\n     * selectTranslation('admin-page').subscribe() - will return the current lang scope translation\r\n     * selectTranslation('admin-page/es').subscribe()\r\n     */\r\n    selectTranslation(lang?: string): Observable<Translation>;\r\n    /**\r\n     * Sets or merge a given translation object to current lang\r\n     *\r\n     * @example\r\n     *\r\n     * setTranslation({ ... })\r\n     * setTranslation({ ... }, 'en')\r\n     * setTranslation({ ... }, 'es', { merge: false } )\r\n     * setTranslation({ ... }, 'todos/en', { merge: false } )\r\n     */\r\n    setTranslation(translation: Translation, lang?: string, options?: SetTranslationOptions): void;\r\n    /**\r\n     * Sets translation key with given value\r\n     *\r\n     * @example\r\n     *\r\n     * setTranslationKey('key', 'value')\r\n     * setTranslationKey('key.nested', 'value')\r\n     * setTranslationKey('key.nested', 'value', 'en')\r\n     * setTranslationKey('key.nested', 'value', 'en', { emitChange: false } )\r\n     */\r\n    setTranslationKey(key: string, value: string, lang?: string, options?: {\r\n        emitChange?: SetTranslationOptions['emitChange'];\r\n    }): void;\r\n    /**\r\n     * Sets the fallback lang for the currently active language\r\n     * @param fallbackLang\r\n     */\r\n    setFallbackLangForMissingTranslation({ fallbackLang }: Pick<TranslocoConfig, 'fallbackLang'>): void;\r\n    /**\r\n     * @internal\r\n     */\r\n    _handleMissingKey(key: string, value: any, params?: HashMap): any;\r\n    /**\r\n     * @internal\r\n     */\r\n    _isLangScoped(lang: string): boolean;\r\n    /**\r\n     * Checks if a given string is one of the specified available languages.\r\n     * @returns\r\n     * True if the given string is an available language.\r\n     * False if the given string is not an available language.\r\n     */\r\n    isLang(lang: string): boolean;\r\n    /**\r\n     * @internal\r\n     *\r\n     * We always want to make sure the global lang is loaded\r\n     * before loading the scope since you can access both via the pipe/directive.\r\n     */\r\n    _loadDependencies(path: string, inlineLoader?: InlineLoader): Observable<Translation | Translation[]>;\r\n    /**\r\n     * @internal\r\n     */\r\n    _completeScopeWithLang(langOrScope: string): string;\r\n    /**\r\n     * @internal\r\n     */\r\n    _setScopeAlias(scope: string, alias: string): void;\r\n    ngOnDestroy(): void;\r\n    private isLoadedTranslation;\r\n    private getAvailableLangsIds;\r\n    private getMissingHandlerData;\r\n    /**\r\n     * Use a fallback translation set for missing keys of the primary language\r\n     * This is unrelated to the fallback language (which changes the active language)\r\n     */\r\n    private useFallbackTranslation;\r\n    private handleSuccess;\r\n    private handleFailure;\r\n    private getMappedScope;\r\n    /**\r\n     * If lang is scope we need to check the following cases:\r\n     * todos/es => in this case we should take `es` as lang\r\n     * todos => in this case we should set the active lang as lang\r\n     */\r\n    private resolveLangAndScope;\r\n    private getObjectByKey;\r\n    private getEntries;\r\n}\r\n"]}